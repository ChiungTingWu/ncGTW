label2path <- function(cut, gtwInfo){
  #label2path4Aosokin Convert label of src and sink to path in primal graph
  # For the graph representation of Aosokin's codes
  # Src and sink edges do not use explicit node names, but other edges do

  # cs = find(labels==0);
  ct <- which(cut == 1)

  nEdgeGrid <- gtwInfo$nEdgeGrid
  nNodeGrid <- gtwInfo$nNodeGrid
  nPix <- gtwInfo$nPix
  pEdgeSS <- gtwInfo$pEdgeSS
  pEdgeEE <- gtwInfo$pEdgeEE
  dEdgeIntSS <- gtwInfo$dEdgeIntSS
  ssTmpPos <- gtwInfo$ssTmpPos
  ss <- gtwInfo$ss
  ee <- gtwInfo$ee

  # cut for within grid
  # not suitable do this pixel by pixel due to the spatial edge
  dtmp <- matrix(0, dim(ee)[1], 2)
  ia <- matrix(is.element(ee[ ,1:2], ct), dim(ee)[1], 2)
  dtmp[ia] <- 1
  isCutEE <- dtmp[ ,1] != dtmp[ , 2]

  # cut to mapping pattern in primal graph
  resPath <- vector('list', nPix)
  for (nn in 1:nPix){
    # cuts within grid
    idx1 <- nEdgeGrid * (nn - 1) + 1
    idx2 <- nEdgeGrid * nn
    cutNow <- isCutEE[idx1:idx2]
    resEE <- pEdgeEE[cutNow, ]

    # src and sink cuts
    idx1 <- nNodeGrid * (nn - 1) + 1
    idx2 <- nNodeGrid * nn
    s0 <- ss[idx1:idx2, ]
    b0 <- cut[idx1:idx2]

    # idxSrcCut = find(s0(:,1)>0 & b0==1);  % nodes that cuts
    idxSrcCut <- which(ssTmpPos[ , 1] != (nPix * nPix + 1) & b0 == TRUE)
    ia <- is.element(dEdgeIntSS[ , 2], idxSrcCut)  # get corresponding edges, src -> node
    resSrc <- pEdgeSS[ia, ]  # the primal edges

    # idxSinkCut = find(s0(:,2)>0 & b0==0);
    idxSinkCut <- which(ssTmpPos[ , 2] != nPix * nPix + 1 & b0 == 0)
    ia <- is.element(dEdgeIntSS[ , 1], idxSinkCut)  # node -> sink
    resSink <- pEdgeSS[ia, ]

    tempPath <- rbind(resEE, resSrc, resSink)
    sorted <- sort.int(tempPath[ , 1], index.return = TRUE)

    resPath[[nn]] <- tempPath[sorted$ix, ]
  }
  return(resPath)
}

warpCurve <- function(curve, path){

  nTps <- length(curve)
  warped <- matrix(0, 1, nTps)
  p0 <- path[ , 1:2]
  idxValid <- (p0[ , 1] >= 1) & (p0[ , 1] <= nTps) & (p0[ , 2] >= 1) & (p0[ , 2] <= nTps)
  p0 <- p0[idxValid, ]

  for (tt in 1:dim(p0)[1]){
    pRef <- p0[tt, 2]
    pTst <- p0[tt, 1]
    warped[pTst] <- max(warped[pTst], curve[pRef])
  }
  return(warped)
}


pathCombine <- function(parPath, path2, parInd){
  dataNum <- max(parInd)
  temp2path <- vector('list', dataNum)

  for (tempInd in 1:dataNum){
    ind <- which(parInd == tempInd, TRUE)
    tempPath1 <- parPath[[ind[2]]][[ind[1]]]
    tempPath2 <- path2[[ind[2]]]
    newPath <- c(0,0)

    for (pixInd in 2:dim(tempPath1)[1]){
      tempPix <- tempPath1[pixInd, 1]
      tempPix2 <- tempPath2[which(tempPath2[ , 2] == tempPix)]

      tempM <- matrix(0, length(tempPix2), 2)
      tempM[ , 1] <- tempPix2
      tempM[ , 2] <- tempPath1[pixInd, 2]
      newPath <- rbind(newPath, tempM)
    }

    for (pixInd in seq(dim(newPath)[1], 2, -1)){
      if ((newPath[pixInd - 1, 1] > newPath[pixInd, 1]) ||
          (newPath[pixInd - 1, 2] > newPath[pixInd, 2])){
        newPath[pixInd, ] <- 0
      }
    }

    newPath <- cbind(newPath, rbind(newPath[2:dim(newPath)[1], ], tempPath2[dim(tempPath2)[1], 3:4]))
    temp2path[[tempInd]] <- newPath
  }
  return(temp2path)
}
