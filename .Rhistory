gtwInfo2 <- buildGTWgraph(ref2, tst2, validMap2, param2, mu, sigma, biP, weiP, 1, path1, gtwPrep$pairMap)
cut2 <- graphCut(gtwInfo2$ss, gtwInfo2$ee)
s2BrokenNum <- cut2[length(cut2)] / smoothnessV2
s2BrokenNumFinal <- s2BrokenNum
s2Final <- 2 * (maxStp2 - 1) * sampNum2 / s2BrokenNum
smoothnessV2 <- s2Final / noiseVar
smo2 <- 50
smoothnessV2 <- s2Final / noiseVar * smo2 / 50
param2 <- initGtwParam(validMap2, noiseVar, maxStp2, smoothnessV2, dia, logt, nor)
gtwInfo2 <- buildGTWgraph( ref2, tst2, validMap2, param2,mu, sigma, biP, weiP, 1, path1, gtwPrep$pairMap)
cut2 <- graphCut(gtwInfo2$ss, gtwInfo2$ee)
path2 <- label2path(cut2, gtwInfo2)
tempPath[[smo]] <- path2
temp2path <- pathCombine( par_path, path2, par_ind);
# stat_result = smoothness_test( XCMS_data, realign_ind, t_M, x_range, rt_v, 1:data_num, temp_2path, data_num);
# temp_range = stat_result(3,2);
# temp_var = stat_result(3,3);
tempRange = 999
pathCombine <- function(parPath, path2, parInd){
dataNum <- max(parInd)
temp2path <- vector('list', dataNum)
for (tempInd in 1:data_num){
ind <- which(parInd == tempInd, TRUE)
tempPath1 <- parPath[[ind[1]]][[ind[2]]]
tempPath2 <- path2[[ind[2]]]
newPath <- c(0,0)
for (pixInd in 2:dim(tempPath1)[1]){
tempPix <- tempPath1[pixInd, 1]
tempPix2 <- tempPath2[which(tempPath2[ , 2] == tempPix)]
tempM <- matrix(0, length(tempPix2), 2)
tempM[ , 1] <- tempPix2
tempM[ , 2] <- tempPath1[pix_ind, 2]
newPath <- rbind(newPath, tempM)
}
for (pixInd in seq(dim(newPath)[1], 2, -1)){
if ((newPath[pixInd - 1, 1] > newPath[pixInd, 1]) ||
(newPath[pixInd - 1, 2] > newPath[pixInd, 2])){
newPath[pixInd, ] <- 0
}
}
newPath <- cbind(newPath, rbind(newPath[2:dim(newPath)[1], ], tempPath2[dim(tempPath2)[1], 3:4]))
temp2path[[tempInd]] <- newPath
}
}
temp2path <- pathCombine( par_path, path2, par_ind);
temp2path <- pathCombine( parPath, path2, parInd);
source('C:/Users/cbil/Dropbox/virginia research/project5/rcode/ncGTW/R/ncGTWwarp.R')
temp2path <- pathCombine( parPath, path2, parInd);
source('C:/Users/cbil/Dropbox/virginia research/project5/rcode/ncGTW/R/ncGTWwarp.R')
temp2path <- pathCombine( parPath, path2, parInd);
source('C:/Users/cbil/Dropbox/virginia research/project5/rcode/ncGTW/R/ncGTWwarp.R')
temp2path <- pathCombine( parPath, path2, parInd);
# stat_result = smoothness_test( XCMS_data, realign_ind, t_M, x_range, rt_v, 1:data_num, temp_2path, data_num);
# temp_range = stat_result(3,2);
# temp_var = stat_result(3,3);
tempRange = 999
tempVar = 999
brokenNum1 <- sum((cut[eeBet[ ,1]] + cut[eeBet[ ,2]]) == 1)
smoM2[smo, 2] <- brokenNum1
smoM2[smo, 3] <- tempRange
smoM2[smo, 4] <- tempVar
if (tempRange <= rangeThre){
break
}
if (smo == 1){
smoM2[2, 1] <- (costMax - cut[length(cut)]) / brokenNum1 + smoTemp
tempCost <- cut[length(cut)] - smoTemp * brokenNum1
smoM2[3, 1] <- (tempCost - costMin) / (s1BrokenNum - brokenNum1)
}
if (parSect > 1){
# fprintf('%-80s%20s\n', 'Starting SAMA top layer.....', datestr(datetime()));
parSuperWarped <- matrix(0, parSect, specLen)
gtwPrep <- buildMultiParaValidmap(superSample, FALSE, 1, 1, biP);
ref <- gtwPrep$ref
tst <- gtwPrep$tst
validMap <- gtwPrep$validMap
sampNum <- dim(tst)[1]
param <- initGtwParam(validMap, noiseVar, maxStp, 10^-32, dia, logt, nor)
gtwInfo <- buildGTWgraph(ref, tst, validMap, param, mu, sigma, biP, weiP)
eeBet <- gtwInfo$ee[(gtwInfo$nEdgeGrid * gtwInfo$nPix + 1) : dim(gtwInfo$ee)[1], ]
param <- initGtwParam(validMap, noiseVar, maxStp, 0, dia, logt, nor)
gtwInfo0 <- buildGTWgraph(ref, tst, validMap, param, mu, sigma, biP, weiP)
cut0 <- graphCut(gtwInfo0$ss, gtwInfo0$ee)
costMin <- cut0[length(cut0)]
s1BrokenNum <- sum((cut0[eeBet[ ,1]] + cut0[eeBet[ ,2]]) == 1)
s1BrokenNumFinal <- s1BrokenNum
param <- initGtwParam(validMap, noiseVar, maxStp, 100000000000, dia, logt, nor)
gtwInfoMerge <- buildGTWgraph(ref, tst, validMap, param, mu, sigma, biP, weiP, 2)
cutMerge <- graphCut(gtwInfoMerge$ss, gtwInfoMerge$ee)
costMax <- cutMerge[length(cutMerge)]
smoTemp <- (costMax - costMin) / s1BrokenNum
s1Final <- smoTemp
# fprintf('%-80s%20s\n', ...
#     sprintf('Obtained the range of the total cost.'), datestr(datetime()));
smoM2 <- matrix(0, 3, 6) + 999
smoM2[1, 1] <- smoTemp
tempPath <- vector('list', dim(smoM2)[1])
for (smo in 1:dim(smoM2)[1]){
param <- initGtwParam(validMap, noiseVar, maxStp, smoM2[smo, 1], dia, logt, nor)
# fprintf('%-80s%20s\n', ...
# sprintf('Built the structure of GTW 1st stage.'), datestr(datetime()));
gtwInfo <- buildGTWgraph(ref, tst, validMap, param, mu, sigma, biP, weiP)
#     fprintf('%-80s%20s\n', ...
#         sprintf('Converted to the 1st maximum flow.'), datestr(datetime()));
cut <- graphCut(gtwInfo$ss, gtwInfo$ee)
path1 <- label2path(cut, gtwInfo)
#     fprintf('%-80s%20s\n', ...
#         sprintf('Got the path.'), datestr(datetime()));
sampNum2 <- dim(superSample)[1]
#    zero_line = zeros([size(samp_num2,1)-1,spec_len]);
validMap2 <- matrix(0, sampNum2, sampNum2)
for (jj in 1:sampNum2){
for (ii in seq(jj + 1, sampNum2, length = max(0, sampNum2 - jj))){
validMap2[ii, jj] <- 1
}
}
maxStp2 <- maxStp
tst2 <- matrix(0, dim(superSample)[1], dim(superSample)[2])
ref2 <- tst2
smoothnessV2 <- 0.00001 / noiseVar
param2 <- initGtwParam(validMap2, noiseVar, maxStp2, smoothnessV2, dia, logt, nor)
gtwInfo2 <- buildGTWgraph(ref2, tst2, validMap2, param2, mu, sigma, biP, weiP, 1, path1, gtwPrep$pairMap)
cut2 <- graphCut(gtwInfo2$ss, gtwInfo2$ee)
s2BrokenNum <- cut2[length(cut2)] / smoothnessV2
s2BrokenNumFinal <- s2BrokenNum
s2Final <- 2 * (maxStp2 - 1) * sampNum2 / s2BrokenNum
smoothnessV2 <- s2Final / noiseVar
#     fprintf('%-80s%20s\n', ...
#         sprintf('Obtained the range of the total cost.'), datestr(datetime()));
#     mpfv_v = zeros(100, 1);
smo2 <- 50
smoothnessV2 <- s2Final / noiseVar * smo2 / 50
param2 <- initGtwParam(validMap2, noiseVar, maxStp2, smoothnessV2, dia, logt, nor)
gtwInfo2 <- buildGTWgraph( ref2, tst2, validMap2, param2,mu, sigma, biP, weiP, 1, path1, gtwPrep$pairMap)
# fprintf('%-80s%20s\n', ...
# sprintf('Converted to the 2nd maximum flow.'), datestr(datetime()));
cut2 <- graphCut(gtwInfo2$ss, gtwInfo2$ee)
path2 <- label2path(cut2, gtwInfo2)
# fprintf('%-80s%20s\n', ...
# sprintf('Solved the 2nd maximum flow.'), datestr(datetime()));
tempPath[[smo]] <- path2
temp2path <- pathCombine( parPath, path2, parInd);
# stat_result = smoothness_test( XCMS_data, realign_ind, t_M, x_range, rt_v, 1:data_num, temp_2path, data_num);
# temp_range = stat_result(3,2);
# temp_var = stat_result(3,3);
tempRange = 999
tempVar = 999
brokenNum1 <- sum((cut[eeBet[ ,1]] + cut[eeBet[ ,2]]) == 1)
smoM2[smo, 2] <- brokenNum1
smoM2[smo, 3] <- tempRange
smoM2[smo, 4] <- tempVar
if (tempRange <= rangeThre){
break
}
if (smo == 1){
smoM2[2, 1] <- (costMax - cut[length(cut)]) / brokenNum1 + smoTemp
tempCost <- cut[length(cut)] - smoTemp * brokenNum1
smoM2[3, 1] <- (tempCost - costMin) / (s1BrokenNum - brokenNum1)
}
# mpfv_v(smo2, 1) = mpfv(par_super_warped, super_sample);
#  end
}
bests <- which.min(smoM2[ , 3] + smoM2[ , 4])
path2 <- tempPath[[bestS]]
for (m in 1:parSect){
parSuperWarped[m, ] <- warpCurve(superSample[m, ], path2[[m]])
}
warpedAll <- matrix(0, dim(data)[1], dim(data)[2])
tempCount <- 0
for (n in 1:parSect){
for (m in 1:parNum[n]){
warpedAll[tempCount + m, ] <- warpCurve(parWarped[m, , n], path2[[n]])
}
}
tempCount <- tempCount + parNum[n]
}
smoM2
parSuperWarped
superSample
warpedAll
warpedAll <- matrix(0, dim(data)[1], dim(data)[2])
tempCount <- 0
for (n in 1:parSect){
for (m in 1:parNum[n]){
warpedAll[tempCount + m, ] <- warpCurve(parWarped[m, , n], path2[[n]])
}
tempCount <- tempCount + parNum[n]
}
warpedAll
mzR::openMSfile
xcms::getEIC
showMethods("getEIC")
showMethods("xcms::getEIC")
library("xcms", lib.loc="~/R/win-library/3.5")
showMethods("getEIC")
getEIC
getEIC()
? getEIC
profFun <- match.profFun(object)
profMat
setwd("C:/Users/cbil/Google Drive/5th project/test dataset3/iQC")
filepath <- "MESA_COMBI_BIO_P2_LP_iQC34.mzML"
con <- file(filepath, "r")
txt <- readLines(con, n=50) ## only reads the first 50 lines, should only take milliseconds
close(con)
txt
system.time()
Sys.time()
Sys.time()
test <- openMSfile(filepath)
Sys.time()
header(test)
Sys.time()
head <- header(test)
Sys.time()
setwd("C:/Users/cbil/Google Drive/5th project/test dataset2/convert_mzxml")
filepath <- "MESA_COMBI_BIO_P2_LP_iQC171.mzXML"
con <- file(filepath, "r")
txt <- readLines(con, n=50) ## only reads the first 50 lines, should only take milliseconds
close(con)
line <- grep("fileName",txt,fixed=T) ## find the line that contains the file name
if (length(line) >0) { ## found it
res <- strsplit(txt[line], ...)  ## extract the result using strsplit etc.
}
Sys.time()
test <- openMSfile(filepath)
Sys.time()
head <- header(test)
Sys.time()
head
View(head)
Sys.time()
xcmssettest <- xcmsSet(filepath)
Sys.time()
xcmsrawtest <- xcmsRaw(filepath)
Sys.time()
Sys.time()
proma <- profMat(xcmsrawtest)
Sys.time()
Sys.time()
xcmsrawtest <- xcmsRaw(filepath, 0.01)
Sys.time()
proma <- profMat(xcmsrawtest)
Sys.time()
mzrange <- c(500,1000)
Sys.time()
seteic <- getEIC(xcmssettest, mzrange)
Sys.time()
raweic <- getEIC(xcmsrawtest, mzrange)
Sys.time()
mzrange <- matrix(0, 1, 2)
mzrange[1, 1] <- 500
mzrange[1, 2] <- 1000
Sys.time()
seteic <- getEIC(xcmssettest, mzrange)
Sys.time()
raweic <- getEIC(xcmsrawtest, mzrange)
Sys.time()
mzrange <- matrix(0, 1, 2)
mzrange[1, 1] <- 999
mzrange[1, 2] <- 1000
Sys.time()
seteic <- getEIC(xcmssettest, mzrange)
Sys.time()
raweic <- getEIC(xcmsrawtest, mzrange)
Sys.time()
Sys.time()
xcmsrawtest <- xcmsRaw(filepath, 0.1)
Sys.time()
proma <- profMat(xcmsrawtest)
Sys.time()
1+1
setwd("C:/Users/cbil/Google Drive/5th project/test dataset2/convert_mzxml")
Sys.time()
mz <- openMSfile(filepath)
Sys.time()
Sys.time()
msd <- openMSfile(filepath)
Sys.time()
hdr <- mzR::header(msd)
Sys.time()
if (any(colnames(hdr) == "polarity"))
header_cols <- c(header_cols, "polarity")
Sys.time()
idx_ms1 <- which(hdr$msLevel == 1)
Sys.time()
## Drop empty spectra; see https://github.com/sneumann/xcms/issues/67
if (dropEmptyScans & length(idx_ms1) > 0) {
idx_ms1 <- idx_ms1[hdr[idx_ms1, "peaksCount"] > 0]
}
Sys.time()
pks <- mzR::peaks(msd, idx_ms1)
Sys.time()
Sys.time()
msd <- openMSfile(filepath)
Sys.time()
hdr <- mzR::header(msd)
Sys.time()
idx_ms1 <- which(hdr$msLevel == 1)
Sys.time()
## Drop empty spectra; see https://github.com/sneumann/xcms/issues/67
if (dropEmptyScans & length(idx_ms1) > 0) {
idx_ms1 <- idx_ms1[hdr[idx_ms1, "peaksCount"] > 0]
}
Sys.time()
pks <- mzR::peaks(msd, idx_ms1)
Sys.time()
Sys.time()
msd <- openMSfile(filepath)
Sys.time()
hdr <- mzR::header(msd)
Sys.time()
idx_ms1 <- which(hdr$msLevel == 1)
Sys.time()
pks <- mzR::peaks(msd, idx_ms1)
Sys.time()
Sys.time()
pks <- mzR::peaks(msd, 51:100)
Sys.time()
Sys.time()
pks <- mzR::peaks(msd, 51:100)
Sys.time()
Sys.time()
pks <- mzR::peaks(msd, 51:500)
Sys.time()
Sys.time()
msd <- openMSfile(filepath)
Sys.time()
pks <- mzR::peaks(msd, 51:500)
Sys.time()
Sys.time()
msd <- openMSfile(filepath)
Sys.time()
pks <- mzR::peaks(msd, 1:2626)
Sys.time()
Sys.time()
msd <- openMSfile(filepath)
Sys.time()
pks <- mzR::peaks(msd, 1:2626)
Sys.time()
ttttt = xcmsrawtest@env
ttttt = xcmsrawtest@env$profile
filepath
mzrange <- matrix(0, 1, 2)
mzrange[1, 1] <- 999
mzrange[1, 2] <- 999.1
Sys.time()
xcmsrawtest <- xcmsRaw(filepath, 0.1)
Sys.time()
raweic <- getEIC(xcmsrawtest, mzrange)
Sys.time()
mzrange <- matrix(0, 1, 2)
mzrange[1, 1] <- 999
mzrange[1, 2] <- 999.1
Sys.time()
xcmsrawtest <- xcmsRaw(filepath, 0.1)
Sys.time()
raweic <- getEIC(xcmsrawtest, mzrange)
Sys.time()
Sys.time()
xcmsrawtest <- xcmsRaw(filepath, 0.01)
Sys.time()
raweic <- getEIC(xcmsrawtest, mzrange)
Sys.time()
Sys.time()
xcmsrawtest <- xcmsRaw(filepath, 1)
Sys.time()
raweic <- getEIC(xcmsrawtest, mzrange)
Sys.time()
Sys.time()
xcmsrawtest <- xcmsRaw(filepath, 0.01)
Sys.time()
raweic <- getEIC(xcmsrawtest, mzrange)
Sys.time()
raweic@mzrange
raweic@rtrange
mzrange <- matrix(0, 1, 2)
mzrange[1, 1] <- 999
mzrange[1, 2] <- 999.1
rtrange <- matrix(0, 1, 2)
rtrange[1, 1] <- 301
rtrange[1, 2] <- 310
Sys.time()
xcmsrawtest <- xcmsRaw(filepath, 0.01)
Sys.time()
raweic <- getEIC(xcmsrawtest, mzrange)
Sys.time()
ee = raweic@rtrange
raweic@rtrange
Sys.time()
raweic <- getEIC(xcmsrawtest, mzrange, rtrange)
Sys.time()
ee = raweic@rtrange
raweic@rtrange
ee = raweic@eic$xcmsRaw[[1]]
View(ee)
mzrange <- matrix(0, 1, 2)
mzrange[1, 1] <- 269.2253
mzrange[1, 2] <- 269.2274
rtrange <- matrix(0, 1, 2)
rtrange[1, 1] <- 322.1551
rtrange[1, 2] <- 355.3655
Sys.time()
raweic <- getEIC(xcmsrawtest, mzrange, rtrange)
Sys.time()
ee = raweic@eic$xcmsRaw[[1]]
View(ee)
plot(ee[.2])
plot(ee[,2])
plot(ee[,2], type = 'l')
filepath <- "C:\Users\cbil\Google Drive\5th project\test dataset2"
mzrange <- matrix(0, 1, 2)
mzrange[1, 1] <- 269.2253
mzrange[1, 2] <- 269.2274
rtrange <- matrix(0, 1, 2)
rtrange[1, 1] <- 322.1551
rtrange[1, 2] <- 355.3655
Sys.time()
xcmsrawtest <- xcmsRaw(filepath, 0.01)
Sys.time()
raweic <- getEIC(xcmsrawtest, mzrange, rtrange)
Sys.time()
filepath <- "C:\Users\cbil\Google Drive\5th project\test dataset2"
filepath <- "C:/Users/cbil/Google Drive/5th project/test dataset2"
mzrange <- matrix(0, 1, 2)
mzrange[1, 1] <- 269.2253
mzrange[1, 2] <- 269.2274
rtrange <- matrix(0, 1, 2)
rtrange[1, 1] <- 322.1551
rtrange[1, 2] <- 355.3655
Sys.time()
xcmsrawtest <- xcmsRaw(filepath, 0.01)
Sys.time()
raweic <- getEIC(xcmsrawtest, mzrange, rtrange)
Sys.time()
Sys.time()
cdfpath <- system.file("mzxml", package = "faahKO")
cdffiles <- list.files(cdfpath, recursive = TRUE, full.names = TRUE)
setwd("C:/Users/cbil/Google Drive/5th project/test dataset2")
filepath <- system.file("mzxml", package = "faahKO")
filepath <- system.file("mzXML", package = "faahKO")
filepath <- list.files(cdfpath, recursive = FALSE, full.names = TRUE)
system.file()
xcmsrawtest <- xcmsRaw()
filepath <- dir(pattern = "mzXML")
Sys.time()
xcmsrawtest <- xcmsRaw(filepath, 0.01)
Sys.time()
raweic <- getEIC(xcmsrawtest, mzrange, rtrange)
Sys.time()
filepath
filepath <- dir(pattern = "mzXML")
# filepath <- list.files(cdfpath, recursive = FALSE, full.names = TRUE)
# filepath <- "C:/Users/cbil/Google Drive/5th project/test dataset2"
mzrange <- matrix(0, 1, 2)
mzrange[1, 1] <- 269.2253
mzrange[1, 2] <- 269.2274
rtrange <- matrix(0, 1, 2)
rtrange[1, 1] <- 322.1551
rtrange[1, 2] <- 355.3655
data <- vector('list', length(filepath))
Sys.time()
for (n in 1:length(data)){
xcmsrawtest <- xcmsRaw(filepath[n], 0.01)
Sys.time()
raweic <- getEIC(xcmsrawtest, mzrange, rtrange)
Sys.time()
data[[n]] <- raweic@eic$xcmsRaw[[1]]
Sys.time()
}
show(Sys.time())
dataM <- matrix(0, 6, 101)
for (n in 1:length(data)){
dataM[n, ] <- data[[n]][,2]
}
View(dataM)
plot(dataM)
matplot(dataM)
matplot(dataM'')
matplot(dataM')
s
d
)
))
''
matplot(t(dataM))
matplot(t(dataM), type = 'l')
print(1)
print('1')
realignGroup = 3
cat("ncGTW is realgining group ", realignGroup)
realignGroup = 3
cat("ncGTW is realgining group", realignGroup)
cat("ncGTW is realgining group", realignGroup, "...")
library(xcms)
CPWmin = 3 # UPLC peakwidths can be as narrow as this - in practice, they are not usually so short but the other parameters ensure noise peaks are not prevalent
CPWmax = 20 # widest peak appears to be about 20s but I generally add some time to this as peaks are not easy to deconvolve by eye
ppm = 15 # calculated from the raw data - see spreadsheet in zipfile
xsnthresh = 200 # generous, but minimum acceptable S/N
snth = 10
LM=F # in practice, including LM files does not appear to really influence final result - also peakpicking does not always appear to work when included
integrate=2 # raw data of sufficient quality that it can be used directly. Would consider waves in presence of strong peak asymmetry/skew, but generally unecessary
RTerror=6 # check drift of peak tops from chromatograms - see spreadsheet in zipfile
MZerror=0.05
prefilter=c(6, 1000)
mzdiff = -1
Sys.time()
ds <- xcmsSet(method="centWave", peakwidth=c(CPWmin,CPWmax), ppm=ppm, noise=xsnthresh, snthresh = snth,
integrate=integrate, prefilter=prefilter, mzdiff = mzdiff)
Sys.time()
close(msd)
close(test)
